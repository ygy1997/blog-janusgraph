"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gpuDetector = exports.processParallelEdges = exports.calculationItemsBBox = exports.isNaN = exports.isViewportChanged = exports.cloneEvent = exports.formatPadding = void 0;

var _util = require("@antv/util");

var _behavior = require("../interface/behavior");

/**
 * turn padding into [top, right, bottom, right]
 * @param  {Number|Array} padding input padding
 * @return {array} output
 */
var formatPadding = function formatPadding(padding) {
  var top = 0;
  var left = 0;
  var right = 0;
  var bottom = 0;

  if ((0, _util.isNumber)(padding)) {
    top = left = right = bottom = padding;
  } else if ((0, _util.isString)(padding)) {
    var intPadding = parseInt(padding, 10);
    top = left = right = bottom = intPadding;
  } else if ((0, _util.isArray)(padding)) {
    top = padding[0];
    right = !(0, _util.isNil)(padding[1]) ? padding[1] : padding[0];
    bottom = !(0, _util.isNil)(padding[2]) ? padding[2] : padding[0];
    left = !(0, _util.isNil)(padding[3]) ? padding[3] : right;
  }

  return [top, right, bottom, left];
};
/**
 * clone event
 * @param e
 */


exports.formatPadding = formatPadding;

var cloneEvent = function cloneEvent(e) {
  var event = new _behavior.G6GraphEvent(e.type, e);
  event.clientX = e.clientX;
  event.clientY = e.clientY;
  event.x = e.x;
  event.y = e.y;
  event.target = e.target;
  event.currentTarget = e.currentTarget;
  event.bubbles = true;
  event.item = e.item;
  return event;
};
/**
 * 判断 viewport 是否改变，通过和单位矩阵对比
 * @param matrix Viewport 的 Matrix
 */


exports.cloneEvent = cloneEvent;

var isViewportChanged = function isViewportChanged(matrix) {
  // matrix 为 null， 则说明没有变化
  if (!matrix) {
    return false;
  }

  var MATRIX_LEN = 9;
  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];

  for (var i = 0; i < MATRIX_LEN; i++) {
    if (matrix[i] !== ORIGIN_MATRIX[i]) {
      return true;
    }
  }

  return false;
};

exports.isViewportChanged = isViewportChanged;

var isNaN = function isNaN(input) {
  return Number.isNaN(Number(input));
};
/**
 * 计算一组 Item 的 BBox
 * @param items 选中的一组Item，可以是 node 或 combo
 */


exports.isNaN = isNaN;

var calculationItemsBBox = function calculationItemsBBox(items) {
  var minx = Infinity;
  var maxx = -Infinity;
  var miny = Infinity;
  var maxy = -Infinity; // 获取已节点的所有最大最小x y值

  for (var i = 0; i < items.length; i++) {
    var element = items[i];
    var bbox = element.getBBox();
    var minX = bbox.minX,
        minY = bbox.minY,
        maxX = bbox.maxX,
        maxY = bbox.maxY;

    if (minX < minx) {
      minx = minX;
    }

    if (minY < miny) {
      miny = minY;
    }

    if (maxX > maxx) {
      maxx = maxX;
    }

    if (maxY > maxy) {
      maxy = maxY;
    }
  }

  var x = Math.floor(minx);
  var y = Math.floor(miny);
  var width = Math.ceil(maxx) - Math.floor(minx);
  var height = Math.ceil(maxy) - Math.floor(miny);
  return {
    x: x,
    y: y,
    width: width,
    height: height,
    minX: minx,
    minY: miny,
    maxX: maxx,
    maxY: maxy
  };
};
/**
 * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠
 * @param edges 边数据集合
 * @param offsetDiff 相邻两边的 offset 之差
 */


exports.calculationItemsBBox = calculationItemsBBox;

var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType) {
  if (offsetDiff === void 0) {
    offsetDiff = 15;
  }

  if (multiEdgeType === void 0) {
    multiEdgeType = 'quadratic';
  }

  if (singleEdgeType === void 0) {
    singleEdgeType = 'line';
  }

  var len = edges.length;
  var cod = offsetDiff * 2;
  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];
  var edgeMap = {};
  var tags = [];
  var reverses = {};

  for (var i = 0; i < len; i++) {
    var edge = edges[i];
    var source = edge.source,
        target = edge.target;
    var sourceTarget = source + "-" + target;
    if (tags[i]) continue;

    if (!edgeMap[sourceTarget]) {
      edgeMap[sourceTarget] = [];
    }

    tags[i] = true;
    edgeMap[sourceTarget].push(edge);

    for (var j = 0; j < len; j++) {
      if (i === j) continue;
      var sedge = edges[j];
      var src = sedge.source;
      var dst = sedge.target; // 两个节点之间共同的边
      // 第一条的source = 第二条的target
      // 第一条的target = 第二条的source

      if (!tags[j]) {
        if (source === dst && target === src) {
          edgeMap[sourceTarget].push(sedge);
          tags[j] = true;
          reverses[src + "|" + dst + "|" + (edgeMap[sourceTarget].length - 1)] = true;
        } else if (source === src && target === dst) {
          edgeMap[sourceTarget].push(sedge);
          tags[j] = true;
        }
      }
    }
  }

  for (var key in edgeMap) {
    var arcEdges = edgeMap[key];
    var length_1 = arcEdges.length;

    for (var k = 0; k < length_1; k++) {
      var current = arcEdges[k];

      if (current.source === current.target) {
        current.type = 'loop'; // 超过8条自环边，则需要重新处理

        current.loopCfg = {
          position: loopPosition[k % 8],
          dist: Math.floor(k / 8) * 20 + 50
        };
        continue;
      }

      if (length_1 === 1) {
        current.type = singleEdgeType;
        continue;
      }

      current.type = multiEdgeType;
      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + "|" + current.target + "|" + k] ? -1 : 1);

      if (length_1 % 2 === 1) {
        current.curveOffset = sign * Math.ceil(k / 2) * cod;
      } else {
        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);
      }
    }
  }

  return edges;
};
/**
 * 调用 gpuDetector.webgl 判断当前浏览器是否支持 webgl。（支持 gpgpu 的浏览器一定也支持 webgl）
 */


exports.processParallelEdges = processParallelEdges;

var gpuDetector = function gpuDetector() {
  if (typeof window === 'undefined' || typeof document === 'undefined') return {};
  return {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function () {
      try {
        var canvas = document.createElement('canvas');
        return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
      } catch (e) {
        return false;
      }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function getWebGLErrorMessage() {
      var element = document.createElement('div');
      element.id = 'webgl-error-message';
      element.style.fontFamily = 'monospace';
      element.style.fontSize = '13px';
      element.style.fontWeight = 'normal';
      element.style.textAlign = 'center';
      element.style.background = '#fff';
      element.style.color = '#000';
      element.style.padding = '1.5em';
      element.style.width = '400px';
      element.style.margin = '5em auto 0';

      if (!this.webgl) {
        element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join('\n') : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join('\n');
      }

      return element;
    },
    addGetWebGLMessage: function addGetWebGLMessage(parameters) {
      parameters = parameters || {};
      var parent = parameters.parent !== undefined ? parameters.parent : document.body;
      var id = parameters.id !== undefined ? parameters.id : 'oldie';
      var element = gpuDetector().getWebGLErrorMessage();
      element.id = id;
      parent.appendChild(element);
    }
  };
};

exports.gpuDetector = gpuDetector;