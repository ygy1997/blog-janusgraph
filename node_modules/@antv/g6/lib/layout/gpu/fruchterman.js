"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = require("tslib");

var _layout = require("../layout");

var _util = require("@antv/util");

var _gWebgpu = require("@antv/g-webgpu");

var _layout2 = require("../../util/layout");

var _fruchtermanShader = require("./fruchtermanShader");

var _layoutConst = require("../worker/layoutConst");

/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */
// compile at runtime in dev mode
// import { Compiler } from '@antv/g-webgpu-compiler';
// import { fruchtermanCode, clusterCode } from './fruchtermanShader';
// use compiled bundle in prod mode

/**
 * fruchterman 布局
 */
var FruchtermanGPULayout =
/** @class */
function (_super) {
  (0, _tslib.__extends)(FruchtermanGPULayout, _super);

  function FruchtermanGPULayout() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /** 布局中心 */


    _this.center = [0, 0];
    /** 停止迭代的最大迭代数 */

    _this.maxIteration = 1000;
    /** 重力大小，影响图的紧凑程度 */

    _this.gravity = 10;
    /** 速度 */

    _this.speed = 1;
    /** 是否产生聚类力 */

    _this.clustering = false;
    /** 根据哪个字段聚类 */

    _this.clusterField = 'cluster';
    /** 聚类力大小 */

    _this.clusterGravity = 10;
    /** 是否启用web worker。前提是在web worker里执行布局，否则无效	*/

    _this.workerEnabled = false;
    _this.nodes = [];
    _this.edges = [];
    _this.width = 300;
    _this.height = 300;
    _this.nodeMap = {};
    _this.nodeIdxMap = {};
    return _this;
  }

  FruchtermanGPULayout.prototype.getDefaultCfg = function () {
    return {
      maxIteration: 1000,
      center: [0, 0],
      gravity: 10,
      speed: 0.1,
      clustering: false,
      clusterGravity: 10
    };
  };
  /**
   * 执行布局
   */


  FruchtermanGPULayout.prototype.execute = function () {
    var _this = this;

    var self = this;
    var nodes = self.nodes;
    var center = self.center;

    if (!nodes || nodes.length === 0) {
      return;
    }

    if (nodes.length === 1) {
      nodes[0].x = center[0];
      nodes[0].y = center[1];
      return;
    }

    var nodeMap = {};
    var nodeIdxMap = {};
    nodes.forEach(function (node, i) {
      if (!(0, _util.isNumber)(node.x)) node.x = Math.random() * _this.width;
      if (!(0, _util.isNumber)(node.y)) node.y = Math.random() * _this.height;
      nodeMap[node.id] = node;
      nodeIdxMap[node.id] = i;
    });
    self.nodeMap = nodeMap;
    self.nodeIdxMap = nodeIdxMap; // layout

    self.run();
  };

  FruchtermanGPULayout.prototype.executeWithWorker = function (canvas, ctx) {
    var _this = this;

    var self = this;
    var nodes = self.nodes;
    var center = self.center;

    if (!nodes || nodes.length === 0) {
      return;
    }

    if (nodes.length === 1) {
      nodes[0].x = center[0];
      nodes[0].y = center[1];
      return;
    }

    var nodeMap = {};
    var nodeIdxMap = {};
    nodes.forEach(function (node, i) {
      if (!(0, _util.isNumber)(node.x)) node.x = Math.random() * _this.width;
      if (!(0, _util.isNumber)(node.y)) node.y = Math.random() * _this.height;
      nodeMap[node.id] = node;
      nodeIdxMap[node.id] = i;
    });
    self.nodeMap = nodeMap;
    self.nodeIdxMap = nodeIdxMap; // layout

    self.run(canvas, ctx);
  };

  FruchtermanGPULayout.prototype.run = function (canvas, ctx) {
    var _this = this;

    var self = this;
    var nodes = self.nodes;
    var edges = self.edges;
    var maxIteration = self.maxIteration;

    if (!self.width && typeof window !== 'undefined') {
      self.width = window.innerWidth;
    }

    if (!self.height && typeof window !== 'undefined') {
      self.height = window.innerHeight;
    }

    var center = self.center;
    var area = self.height * self.width;
    var maxDisplace = Math.sqrt(area) / 10;
    var k2 = area / (nodes.length + 1);
    var k = Math.sqrt(k2);
    var speed = self.speed;
    var clustering = self.clustering;

    var _a = (0, _layout2.attributesToTextureData)([self.clusterField], nodes),
        attributeArray = _a.array,
        clusterCount = _a.count;

    var numParticles = nodes.length;

    var _b = (0, _layout2.buildTextureData)(nodes, edges),
        maxEdgePerVetex = _b.maxEdgePerVetex,
        nodesEdgesArray = _b.array;

    var workerEnabled = self.workerEnabled;
    var world;

    if (workerEnabled) {
      world = _gWebgpu.World.create({
        canvas: canvas,
        engineOptions: {
          supportCompute: true
        }
      });
    } else {
      world = _gWebgpu.World.create({
        engineOptions: {
          supportCompute: true
        }
      });
    } // compile at runtime in dev mode
    // const compiler = new Compiler();
    // const fruchtermanBundle = compiler.compileBundle(fruchtermanCode);
    // const clusterBundle = compiler.compileBundle(clusterCode);
    // use compiled bundle in prod mode
    // console.log(fruchtermanBundle.toString());
    // console.log(clusterBundle.toString());


    var onLayoutEnd = self.onLayoutEnd;
    var clusterCenters = [];

    for (var i = 0; i < clusterCount; i++) {
      clusterCenters.push(0, 0, 0, 0);
    }

    var kernelFruchterman = world.createKernel(_fruchtermanShader.fruchtermanBundle).setDispatch([numParticles, 1, 1]).setBinding({
      u_Data: nodesEdgesArray,
      u_K: k,
      u_K2: k2,
      u_Gravity: self.gravity,
      u_ClusterGravity: self.clusterGravity,
      u_Speed: speed,
      u_MaxDisplace: maxDisplace,
      u_Clustering: clustering ? 1 : 0,
      u_Center: center,
      u_AttributeArray: attributeArray,
      u_ClusterCenters: clusterCenters,
      MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
      VERTEX_COUNT: numParticles
    });
    var kernelCluster;

    if (clustering) {
      kernelCluster = world.createKernel(_fruchtermanShader.clusterBundle).setDispatch([clusterCount, 1, 1]).setBinding({
        u_Data: nodesEdgesArray,
        u_NodeAttributes: attributeArray,
        u_ClusterCenters: clusterCenters,
        VERTEX_COUNT: numParticles,
        CLUSTER_COUNT: clusterCount
      });
    }

    var execute = function execute() {
      return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
        var i, finalParticleData;
        return (0, _tslib.__generator)(this, function (_a) {
          switch (_a.label) {
            case 0:
              i = 0;
              _a.label = 1;

            case 1:
              if (!(i < maxIteration)) return [3
              /*break*/
              , 6]; // eslint-disable-next-line no-await-in-loop

              return [4
              /*yield*/
              , kernelFruchterman.execute()];

            case 2:
              // eslint-disable-next-line no-await-in-loop
              _a.sent();

              if (!clustering) return [3
              /*break*/
              , 4];
              kernelCluster.setBinding({
                u_Data: kernelFruchterman
              }); // eslint-disable-next-line no-await-in-loop

              return [4
              /*yield*/
              , kernelCluster.execute()];

            case 3:
              // eslint-disable-next-line no-await-in-loop
              _a.sent();

              kernelFruchterman.setBinding({
                u_ClusterCenters: kernelCluster
              });
              _a.label = 4;

            case 4:
              kernelFruchterman.setBinding({
                u_MaxDisplace: maxDisplace *= 0.99
              });
              _a.label = 5;

            case 5:
              i++;
              return [3
              /*break*/
              , 1];

            case 6:
              return [4
              /*yield*/
              , kernelFruchterman.getOutput()];

            case 7:
              finalParticleData = _a.sent();

              if (canvas) {
                // 传递数据给主线程
                ctx.postMessage({
                  type: _layoutConst.LAYOUT_MESSAGE.GPUEND,
                  vertexEdgeData: finalParticleData
                });
              } else {
                nodes.forEach(function (node, i) {
                  var x = finalParticleData[4 * i];
                  var y = finalParticleData[4 * i + 1];
                  node.x = x;
                  node.y = y;
                });
              }

              if (onLayoutEnd) onLayoutEnd();
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    execute();
  };

  return FruchtermanGPULayout;
}(_layout.BaseLayout);

var _default = FruchtermanGPULayout;
exports.default = _default;