"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = require("tslib");

var _layout = require("../layout");

var _util = require("@antv/util");

var _gWebgpu = require("@antv/g-webgpu");

var _layout2 = require("../../util/layout");

var _math = require("../../util/math");

var _gForceShader = require("./gForceShader");

var _layoutConst = require("../worker/layoutConst");

/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */
// import { gForceCode, aveMovementCode } from './gForceShader';

/**
 * graphin 中的 force 布局
 */
var GForceGPULayout =
/** @class */
function (_super) {
  (0, _tslib.__extends)(GForceGPULayout, _super);

  function GForceGPULayout() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /** 布局中心 */


    _this.center = [0, 0];
    /** 停止迭代的最大迭代数 */

    _this.maxIteration = 1000;
    /** 弹簧引力系数 */

    _this.edgeStrength = 200;
    /** 斥力系数 */

    _this.nodeStrength = 1000;
    /** 库伦系数 */

    _this.coulombDisScale = 0.005;
    /** 阻尼系数 */

    _this.damping = 0.9;
    /** 最大速度 */

    _this.maxSpeed = 1000;
    /** 一次迭代的平均移动距离小于该值时停止迭代 */

    _this.minMovement = 1;
    /** 迭代中衰减 */

    _this.interval = 0.02;
    /** 斥力的一个系数 */

    _this.factor = 1;
    /** 理想边长 */

    _this.linkDistance = 1;
    /** 重力大小 */

    _this.gravity = 10;
    /** 是否启用web worker。前提是在web worker里执行布局，否则无效	*/

    _this.workerEnabled = false;
    _this.nodes = [];
    _this.edges = [];
    _this.width = 300;
    _this.height = 300;
    _this.nodeMap = {};
    _this.nodeIdxMap = {};
    return _this;
  }

  GForceGPULayout.prototype.getDefaultCfg = function () {
    return {
      maxIteration: 2000,
      center: [0, 0],
      gravity: 10,
      clustering: false,
      clusterGravity: 10
    };
  };
  /**
   * 执行布局
   */


  GForceGPULayout.prototype.execute = function () {
    var self = this;
    var nodes = self.nodes;
    var center = self.center;

    if (!nodes || nodes.length === 0) {
      return;
    }

    if (nodes.length === 1) {
      nodes[0].x = center[0];
      nodes[0].y = center[1];
      return;
    }

    var nodeMap = {};
    var nodeIdxMap = {};
    nodes.forEach(function (node, i) {
      if (!(0, _util.isNumber)(node.x)) node.x = Math.random() * self.width;
      if (!(0, _util.isNumber)(node.y)) node.y = Math.random() * self.height;
      nodeMap[node.id] = node;
      nodeIdxMap[node.id] = i;
    });
    self.nodeMap = nodeMap;
    self.nodeIdxMap = nodeIdxMap;
    self.nodeStrength = (0, _layout2.proccessToFunc)(self.nodeStrength, 1);
    self.edgeStrength = (0, _layout2.proccessToFunc)(self.edgeStrength, 1); // layout

    self.run();
  };

  GForceGPULayout.prototype.executeWithWorker = function (canvas, ctx) {
    var self = this;
    var nodes = self.nodes;
    var center = self.center;

    if (!nodes || nodes.length === 0) {
      return;
    }

    if (nodes.length === 1) {
      nodes[0].x = center[0];
      nodes[0].y = center[1];
      return;
    }

    var nodeMap = {};
    var nodeIdxMap = {};
    nodes.forEach(function (node, i) {
      if (!(0, _util.isNumber)(node.x)) node.x = Math.random() * self.width;
      if (!(0, _util.isNumber)(node.y)) node.y = Math.random() * self.height;
      nodeMap[node.id] = node;
      nodeIdxMap[node.id] = i;
    });
    self.nodeMap = nodeMap;
    self.nodeIdxMap = nodeIdxMap;
    self.nodeStrength = (0, _layout2.proccessToFunc)(self.nodeStrength, 1);
    self.edgeStrength = (0, _layout2.proccessToFunc)(self.edgeStrength, 1); // layout

    self.run(canvas, ctx);
  };

  GForceGPULayout.prototype.run = function (canvas, ctx) {
    var _this = this;

    var self = this;
    var nodes = self.nodes;
    var edges = self.edges;
    var maxIteration = self.maxIteration;

    if (!self.width && typeof window !== 'undefined') {
      self.width = window.innerWidth;
    }

    if (!self.height && typeof window !== 'undefined') {
      self.height = window.innerHeight;
    }

    var numParticles = nodes.length;
    self.linkDistance = (0, _layout2.proccessToFunc)(self.linkDistance);
    self.edgeStrength = (0, _layout2.proccessToFunc)(self.edgeStrength);

    var _a = (0, _layout2.buildTextureDataWithTwoEdgeAttr)(nodes, edges, self.linkDistance, self.edgeStrength),
        maxEdgePerVetex = _a.maxEdgePerVetex,
        nodesEdgesArray = _a.array; // init degree for mass


    self.degrees = (0, _math.getDegree)(nodes.length, self.nodeIdxMap, edges);
    var masses = [];
    var nodeStrengths = [];
    var centerXs = [];
    var centerYs = [];
    var centerGravities = [];

    if (!self.getMass) {
      self.getMass = function (d) {
        return self.degrees[self.nodeIdxMap[d.id]] || 1;
      };
    }

    var gravity = self.gravity;
    var center = self.center;
    nodes.forEach(function (node, i) {
      masses.push(self.getMass(node));
      nodeStrengths.push(self.nodeStrength(node));
      if (!self.degrees[i]) self.degrees[i] = 0;
      var nodeGravity = [center[0], center[1], gravity];

      if (self.getCenter) {
        var customCenter = self.getCenter(node, self.degrees[i]);

        if (customCenter && (0, _util.isNumber)(customCenter[0]) && (0, _util.isNumber)(customCenter[1]) && (0, _util.isNumber)(customCenter[2])) {
          nodeGravity = customCenter;
        }
      }

      centerXs.push(nodeGravity[0]);
      centerYs.push(nodeGravity[1]);
      centerGravities.push(nodeGravity[2]);
    }); // 每个节点的额外属性占两个数组各一格，nodeAttributeArray1 中是：mass, degree, nodeSterngth, 0

    var nodeAttributeArray1 = (0, _layout2.arrayToTextureData)([masses, self.degrees, nodeStrengths]); // nodeAttributeArray2 中是：centerX, centerY, gravity, 0, 

    var nodeAttributeArray2 = (0, _layout2.arrayToTextureData)([centerXs, centerYs, centerGravities]);
    var workerEnabled = self.workerEnabled;
    var world;

    if (workerEnabled) {
      world = _gWebgpu.World.create({
        canvas: canvas,
        engineOptions: {
          supportCompute: true
        }
      });
    } else {
      world = _gWebgpu.World.create({
        engineOptions: {
          supportCompute: true
        }
      });
    } // TODO: 最终的预编译代码放入到 gForceShader.ts 中直接引入，不再需要下面三行
    // const compiler = new Compiler();
    // const gForceBundle = compiler.compileBundle(gForceCode);
    // console.log(gForceBundle.toString());


    var onLayoutEnd = self.onLayoutEnd;
    var initPreviousData = [];
    nodesEdgesArray.forEach(function (value) {
      initPreviousData.push(value);
    });

    for (var i = 0; i < 4; i++) {
      initPreviousData.push(0);
    }

    var kernelGForce = world.createKernel(_gForceShader.gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({
      u_Data: nodesEdgesArray,
      u_damping: self.damping,
      u_maxSpeed: self.maxSpeed,
      u_minMovement: self.minMovement,
      u_coulombDisScale: self.coulombDisScale,
      u_factor: self.factor,
      u_NodeAttributeArray1: nodeAttributeArray1,
      u_NodeAttributeArray2: nodeAttributeArray2,
      MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
      VERTEX_COUNT: numParticles,
      u_AveMovement: initPreviousData,
      u_interval: self.interval // 每次迭代更新，首次设置为 interval，在 onIterationCompleted 中更新

    }); // const aveMovementBundle = compiler.compileBundle(aveMovementCode);
    // console.log(aveMovementBundle.toString());

    var kernelAveMovement = world.createKernel(_gForceShader.aveMovementBundle).setDispatch([1, 1, 1]).setBinding({
      u_Data: nodesEdgesArray,
      VERTEX_COUNT: numParticles,
      u_AveMovement: [0, 0, 0, 0]
    }); // 执行迭代
    // let midRes = nodesEdgesArray;

    var execute = function execute() {
      return (0, _tslib.__awaiter)(_this, void 0, void 0, function () {
        var i, stepInterval, finalParticleData;
        return (0, _tslib.__generator)(this, function (_a) {
          switch (_a.label) {
            case 0:
              i = 0;
              _a.label = 1;

            case 1:
              if (!(i < maxIteration)) return [3
              /*break*/
              , 5]; // TODO: 似乎都来自 kernelGForce 是一个引用
              // 当前坐标作为下一次迭代的 PreviousData
              // if (i > 0) {
              //   kernelAveMovement.setBinding({
              //     u_PreviousData: kernelGForce
              //   });
              // }
              // eslint-disable-next-line no-await-in-loop

              return [4
              /*yield*/
              , kernelGForce.execute()];

            case 2:
              // TODO: 似乎都来自 kernelGForce 是一个引用
              // 当前坐标作为下一次迭代的 PreviousData
              // if (i > 0) {
              //   kernelAveMovement.setBinding({
              //     u_PreviousData: kernelGForce
              //   });
              // }
              // eslint-disable-next-line no-await-in-loop
              _a.sent(); // midRes = await kernelGForce.getOutput();
              // 每次迭代完成后
              // 计算平均位移，用于提前终止迭代


              kernelAveMovement.setBinding({
                u_Data: kernelGForce
              }); // eslint-disable-next-line no-await-in-loop

              return [4
              /*yield*/
              , kernelAveMovement.execute()];

            case 3:
              // eslint-disable-next-line no-await-in-loop
              _a.sent();

              stepInterval = Math.max(0.02, self.interval - i * 0.002);
              kernelGForce.setBinding({
                u_interval: stepInterval,
                u_AveMovement: kernelAveMovement
              });
              _a.label = 4;

            case 4:
              i++;
              return [3
              /*break*/
              , 1];

            case 5:
              return [4
              /*yield*/
              , kernelGForce.getOutput()];

            case 6:
              finalParticleData = _a.sent(); // 所有迭代完成后

              if (canvas) {
                // 传递数据给主线程
                ctx.postMessage({
                  type: _layoutConst.LAYOUT_MESSAGE.GPUEND,
                  vertexEdgeData: finalParticleData
                });
              } else {
                nodes.forEach(function (node, i) {
                  var x = finalParticleData[4 * i];
                  var y = finalParticleData[4 * i + 1];
                  node.x = x;
                  node.y = y;
                });
              }

              if (onLayoutEnd) onLayoutEnd();
              return [2
              /*return*/
              ];
          }
        });
      });
    };

    execute();
  };

  return GForceGPULayout;
}(_layout.BaseLayout);

var _default = GForceGPULayout;
exports.default = _default;