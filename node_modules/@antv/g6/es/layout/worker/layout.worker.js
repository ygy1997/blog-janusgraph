/**
 * @fileoverview web worker for layout
 * @author changzhe.zb@antfin.com
 */
import Layout from '../index';
import { LAYOUT_MESSAGE } from './layoutConst'; // test

var gCode2 = "\nimport { globalInvocationID, debug } from 'g-webgpu';\n\nconst VERTEX_COUNT;\nconst CLUSTER_COUNT;\n\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n\n  @in\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\n\n  @out\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\n\n  @main\n  compute() {\n    // init the cluster centers\n    for (let i = 0; i < CLUSTER_COUNT; i++) {\n      this.u_ClusterCenters[i] = [ 0, 0, 0, 0 ]\n    }\n\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      const attributes = this.u_NodeAttributes[j];\n      const clusterIdx: float = attributes[0];\n      const center = this.u_ClusterCenters[int(clusterIdx)];\n      const sumx: float = center.x + this.u_Data[j].x;\n      const sumy: float = center.y + this.u_Data[j].y;\n      const count = center.z + 1;\n      this.u_ClusterCenters[int(clusterIdx)] =\n      [\n        sumx, // cx\n        sumy, // cy\n        count, // nodeCount\n        clusterIdx,\n      ]\n      // !!! sumx sumy count \u6709\u503C\uFF0C\u4F46 this.u_ClusterCenters[int(clusterIdx)] \u672A\u88AB\u8D4B\u503C\u6210\u529F\n      // debug(this.u_ClusterCenters[int(clusterIdx)].x);\n    }\n\n    for (let k = 0; k < CLUSTER_COUNT; k++) {\n      const center = this.u_ClusterCenters[k];\n      this.u_ClusterCenters[k] = [\n        center.x / center.z,\n        center.y / center.z,\n        center.z,\n        center.w\n      ];\n    }\n  }\n}\n";
var gpuVariableMapping = {
  k: 'u_K',
  k2: 'u_K2',
  gravity: 'u_Gravity',
  clusterGravity: 'u_ClusterGravity',
  speed: 'u_Speed',
  maxDisplace: 'u_MaxDisplace',
  clustering: 'u_Clustering',
  attributeArray: 'u_AttributeArray',
  centerX: 'u_CenterX',
  centerY: 'u_CenterY',
  maxEdgePerVetex: 'MAX_EDGE_PER_VERTEX',
  nodeNum: 'VERTEX_COUNT'
};
var ctx = self;

function isLayoutMessage(event) {
  var type = event.data.type;
  return type === LAYOUT_MESSAGE.RUN || type === LAYOUT_MESSAGE.GPURUN;
}

function handleLayoutMessage(event) {
  var type = event.data.type;

  switch (type) {
    case LAYOUT_MESSAGE.RUN:
      {
        var _a = event.data,
            nodes = _a.nodes,
            edges = _a.edges,
            _b = _a.layoutCfg,
            layoutCfg = _b === void 0 ? {} : _b;
        var layoutType = layoutCfg.type;
        var LayoutClass = Layout[layoutType];

        if (!LayoutClass) {
          ctx.postMessage({
            type: LAYOUT_MESSAGE.ERROR,
            message: "layout " + layoutType + " not found"
          });
          break;
        }

        var layoutMethod = new LayoutClass(layoutCfg);
        layoutMethod.init({
          nodes: nodes,
          edges: edges
        });
        layoutMethod.execute();
        ctx.postMessage({
          type: LAYOUT_MESSAGE.END,
          nodes: nodes
        });
        layoutMethod.destroy();
        break;
      }

    case LAYOUT_MESSAGE.GPURUN:
      {
        var _c = event.data,
            nodes = _c.nodes,
            edges = _c.edges,
            _d = _c.layoutCfg,
            layoutCfg = _d === void 0 ? {} : _d,
            canvas = _c.canvas;
        var layoutType = layoutCfg.type;
        var LayoutClass = Layout[layoutType];

        if (!LayoutClass) {
          ctx.postMessage({
            type: LAYOUT_MESSAGE.ERROR,
            message: "layout " + layoutType + " not found"
          });
          break;
        }

        if (layoutType.split('-')[1] !== 'gpu') {
          ctx.postMessage({
            type: LAYOUT_MESSAGE.ERROR,
            message: "layout " + layoutType + " does not support GPU"
          });
          break;
        }

        var layoutMethod = new LayoutClass(layoutCfg);
        layoutMethod.init({
          nodes: nodes,
          edges: edges
        });
        layoutMethod.executeWithWorker(canvas, ctx);
        break;
      }

    default:
      break;
  }
} // listen to message posted to web worker


ctx.onmessage = function (event) {
  if (isLayoutMessage(event)) {
    handleLayoutMessage(event);
  }
}; // https://stackoverflow.com/questions/50210416/webpack-worker-loader-fails-to-compile-typescript-worker


export default null;