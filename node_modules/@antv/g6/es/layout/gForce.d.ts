/**
 * @fileOverview fruchterman layout
 * @author shiwu.wyy@antfin.com
 */
import { EdgeConfig, IPointTuple, NodeConfig, NodeIdxMap } from '../types';
import { BaseLayout } from './layout';
declare type NodeMap = {
    [key: string]: NodeConfig;
};
/**
 * graphin 中的 force 布局
 */
export default class GForceLayout extends BaseLayout {
    /** 布局中心 */
    center: IPointTuple;
    /** 停止迭代的最大迭代数 */
    maxIteration: number;
    /** 弹簧引力系数 */
    edgeStrength: number | ((d?: any) => number) | undefined;
    /** 斥力系数 */
    nodeStrength: number | ((d?: any) => number) | undefined;
    /** 库伦系数 */
    coulombDisScale: number;
    /** 阻尼系数 */
    damping: number;
    /** 最大速度 */
    maxSpeed: number;
    /** 一次迭代的平均移动距离小于该值时停止迭代 */
    minMovement: number;
    /** 迭代中衰减 */
    interval: number;
    /** 斥力的一个系数 */
    factor: number;
    /** 每个节点质量的回调函数，若不指定，则默认使用度数作为节点质量 */
    getMass: ((d?: any) => number) | undefined;
    /** 每个节点中心力的 x、y、强度的回调函数，若不指定，则没有额外中心力 */
    getCenter: ((d?: any, degree?: number) => number[]) | undefined;
    /** 理想边长 */
    linkDistance: number | ((d?: any) => number) | undefined;
    /** 重力大小 */
    gravity: number;
    /** 是否防止重叠 */
    preventOverlap: boolean;
    /** 防止重叠时的节点大小，默认从节点数据中取 size */
    nodeSize: number | number[] | ((d?: any) => number) | undefined;
    /** 防止重叠时的节点之间最小间距 */
    nodeSpacing: number | number[] | ((d?: any) => number) | undefined;
    /** 每次迭代结束的回调函数 */
    tick: () => void;
    /** 是否允许每次迭代结束调用回调函数 */
    enableTick: boolean;
    nodes: NodeConfig[];
    edges: EdgeConfig[];
    width: number;
    height: number;
    nodeMap: NodeMap;
    nodeIdxMap: NodeIdxMap;
    canvasEl: HTMLCanvasElement;
    onLayoutEnd: () => void;
    /** 存储节点度数 */
    private degrees;
    /** 迭代中的标识 */
    private timeInterval;
    getDefaultCfg(): {
        maxIteration: number;
        center: number[];
        gravity: number;
        enableTick: boolean;
    };
    /**
     * 执行布局
     */
    execute(): void;
    run(): void;
    calRepulsive(accArray: any, nodes: any): void;
    calAttractive(accArray: any, edges: any): void;
    calGravity(accArray: any, nodes: any): void;
    updateVelocity(accArray: any, velArray: any, stepInterval: any, nodes: any): void;
    updatePosition(velArray: any, stepInterval: any, nodes: any): void;
    stop(): void;
}
export {};
