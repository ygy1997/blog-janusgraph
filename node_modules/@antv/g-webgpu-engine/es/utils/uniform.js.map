{"version":3,"sources":["../../src/utils/uniform.ts"],"names":["extractUniforms","uniforms","extractedUniforms","Object","keys","forEach","uniformName","extractUniformsRecursively","uniformValue","prefix","Array","isArray","childName","child","idx"],"mappings":";;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,eAAT,CAAyBC,QAAzB,EAIL;AACA,MAAMC,iBAAiB,GAAG,EAA1B;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYH,QAAZ,EAAsBI,OAAtB,CAA8B,UAACC,WAAD,EAAiB;AAC7CC,IAAAA,0BAA0B,CACxBD,WADwB,EAExBL,QAAQ,CAACK,WAAD,CAFgB,EAGxBJ,iBAHwB,EAIxB,EAJwB,CAA1B;AAMD,GAPD;AASA,SAAOA,iBAAP;AACD;;AAED,SAASK,0BAAT,CACED,WADF,EAEEE,YAFF,EAGEP,QAHF,EAMEQ,MANF,EAOE;AACA,MACED,YAAY,KAAK,IAAjB,IACA,OAAOA,YAAP,KAAwB,QADxB,IACoC;AACpC,SAAOA,YAAP,KAAwB,SAFxB,IAEqC;AACpCE,EAAAA,KAAK,CAACC,OAAN,CAAcH,YAAd,KAA+B,OAAOA,YAAY,CAAC,CAAD,CAAnB,KAA2B,QAH3D,IAGwE;AACxE,gBAAaA,YAAb,CAJA,IAI8B;AAC9B;AACAA,EAAAA,YAAY,KAAK,EANjB,IAOA,YAAYA,YARd,EASE;AACAP,IAAAA,QAAQ,WAAIQ,MAAM,IAAIA,MAAM,GAAG,GAAvB,SAA6BH,WAA7B,EAAR,GAAsDE,YAAtD;AACA;AACD,GAbD,CAeA;;;AACA,MAAI,eAAcA,YAAd,CAAJ,EAAiC;AAC/BL,IAAAA,MAAM,CAACC,IAAP,CAAYI,YAAZ,EAA0BH,OAA1B,CAAkC,UAACO,SAAD,EAAe;AAC/CL,MAAAA,0BAA0B,CACxBK,SADwB,EAExB;AACAJ,MAAAA,YAAY,CAACI,SAAD,CAHY,EAIxBX,QAJwB,YAKrBQ,MAAM,IAAIA,MAAM,GAAG,GALE,SAKIH,WALJ,EAA1B;AAOD,KARD;AASD,GA1BD,CA4BA;;;AACA,MAAII,KAAK,CAACC,OAAN,CAAcH,YAAd,CAAJ,EAAiC;AAC/B;AACAA,IAAAA,YAAY,CAACH,OAAb,CAAqB,UAACQ,KAAD,EAAQC,GAAR,EAAgB;AACnCX,MAAAA,MAAM,CAACC,IAAP,CAAYS,KAAZ,EAAmBR,OAAnB,CAA2B,UAACO,SAAD,EAAe;AACxCL,QAAAA,0BAA0B,CACxBK,SADwB,EAExB;AACAC,QAAAA,KAAK,CAACD,SAAD,CAHmB,EAIxBX,QAJwB,YAKrBQ,MAAM,IAAIA,MAAM,GAAG,GALE,SAKIH,WALJ,cAKmBQ,GALnB,OAA1B;AAOD,OARD;AASD,KAVD;AAWD;AACF","sourcesContent":["import { IUniform } from '@antv/g-webgpu-core';\nimport { isPlainObject, isTypedArray } from 'lodash';\n\n/**\n * 考虑结构体命名, eg:\n * a: { b: 1 }  ->  'a.b'\n * a: [ { b: 1 } ] -> 'a[0].b'\n */\nexport function extractUniforms(uniforms: {\n  [key: string]: IUniform;\n}): {\n  [key: string]: IUniform;\n} {\n  const extractedUniforms = {};\n  Object.keys(uniforms).forEach((uniformName) => {\n    extractUniformsRecursively(\n      uniformName,\n      uniforms[uniformName],\n      extractedUniforms,\n      '',\n    );\n  });\n\n  return extractedUniforms;\n}\n\nfunction extractUniformsRecursively(\n  uniformName: string,\n  uniformValue: IUniform,\n  uniforms: {\n    [key: string]: IUniform;\n  },\n  prefix: string,\n) {\n  if (\n    uniformValue === null ||\n    typeof uniformValue === 'number' || // u_A: 1\n    typeof uniformValue === 'boolean' || // u_A: false\n    (Array.isArray(uniformValue) && typeof uniformValue[0] === 'number') || // u_A: [1, 2, 3]\n    isTypedArray(uniformValue) || // u_A: Float32Array\n    // @ts-ignore\n    uniformValue === '' ||\n    'resize' in uniformValue\n  ) {\n    uniforms[`${prefix && prefix + '.'}${uniformName}`] = uniformValue;\n    return;\n  }\n\n  // u_Struct.a.b.c\n  if (isPlainObject(uniformValue)) {\n    Object.keys(uniformValue).forEach((childName) => {\n      extractUniformsRecursively(\n        childName,\n        // @ts-ignore\n        uniformValue[childName],\n        uniforms,\n        `${prefix && prefix + '.'}${uniformName}`,\n      );\n    });\n  }\n\n  // u_Struct[0].a\n  if (Array.isArray(uniformValue)) {\n    // @ts-ignore\n    uniformValue.forEach((child, idx) => {\n      Object.keys(child).forEach((childName) => {\n        extractUniformsRecursively(\n          childName,\n          // @ts-ignore\n          child[childName],\n          uniforms,\n          `${prefix && prefix + '.'}${uniformName}[${idx}]`,\n        );\n      });\n    });\n  }\n}\n"],"file":"uniform.js"}