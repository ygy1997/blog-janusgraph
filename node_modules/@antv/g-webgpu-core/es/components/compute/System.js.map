{"version":3,"sources":["../../../src/components/compute/System.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA","sourcesContent":["// import { AST_TOKEN_TYPES, DefineValuePlaceholder, GLSLContext, STORAGE_CLASS, Target } from '@antv/g-webgpu-compiler';\n// import { inject, injectable } from 'inversify';\n// import { Component, container, createEntity, Entity } from '../..';\n// import { ComponentManager } from '../../ComponentManager';\n// import { IDENTIFIER } from '../../identifier';\n// import { ISystem } from '../../ISystem';\n// import { isSafari } from '../../utils/isSafari';\n// import { IRendererService } from '../renderer/IRendererService';\n// import { ComputeComponent } from './ComputeComponent';\n// import { IComputeStrategy } from './IComputeStrategy';\n// import { ComputeType } from './interface';\n\n// @injectable()\n// export class ComputeSystem implements ISystem {\n//   @inject(IDENTIFIER.ComputeComponentManager)\n//   private readonly compute: ComponentManager<ComputeComponent>;\n\n//   @inject(IDENTIFIER.RenderEngine)\n//   private readonly engine: IRendererService;\n\n//   public async execute() {\n//     // 首先开启当前 frame 的 compute pass\n//     this.engine.clear({});\n\n//     // // 考虑多个计算程序之间的依赖关系\n//     // // 先找到多个计算程序中最大的迭代次数，然后按顺序执行\n//     // let maxIteration = 0;\n//     // this.compute.map((entity, component) => {\n//     //   if (component.maxIteration > maxIteration) {\n//     //     maxIteration = component.maxIteration;\n//     //   }\n//     // });\n\n//     // // 首先所有计算程序依次初始化\n//     // for (let j = 0; j < this.compute.getCount(); j++) {\n//     //   const component = this.compute.getComponent(j);\n//     //   if (!component.finished) {\n//     //     if (component.dirty) {\n//     //       await this.compile(component);\n//     //       component.dirty = false;\n//     //     }\n//     //   }\n//     // }\n\n//     // for (let i = 0; i < maxIteration; i++) {\n//     //   for (let j = 0; j < this.compute.getCount(); j++) {\n//     //     const component = this.compute.getComponent(j);\n//     //     if (!component.finished) {\n//     //       if (component.iteration <= component.maxIteration - 1) {\n//     //         component.model.run();\n//     //         if (component.onIterationCompleted) {\n//     //           await component.onIterationCompleted(component.iteration);\n//     //         }\n//     //         component.iteration++;\n//     //       } else {\n//     //         component.finished = true;\n//     //         if (component.onCompleted) {\n//     //           component.onCompleted(await component.model.readData());\n//     //         }\n//     //       }\n//     //     }\n//     //   }\n//     // }\n//   }\n\n//   public tearDown() {\n//     this.compute.forEach((_, compute) => {\n//       compute.model.destroy();\n//     });\n//     this.compute.clear();\n//   }\n\n//   public createComputePipeline({\n//     type = 'layout',\n//     target,\n//     precompiledBundle,\n//     dispatch = [1, 1, 1],\n//     maxIteration = 1,\n//     onCompleted = null,\n//     onIterationCompleted = null,\n//   }: {\n//     type: ComputeType;\n//     target?: Target;\n//     precompiledBundle: string;\n//     dispatch: [number, number, number];\n//     maxIteration?: number;\n//     onCompleted?:\n//       | ((\n//           particleData:\n//             | Float32Array\n//             | Float64Array\n//             | Int8Array\n//             | Uint8Array\n//             | Uint8ClampedArray\n//             | Int16Array\n//             | Uint16Array\n//             | Int32Array\n//             | Uint32Array,\n//         ) => void)\n//       | null;\n//     onIterationCompleted?: ((iteration: number) => Promise<void>) | null;\n//   }) {\n//     const entity = createEntity();\n//     // 默认优先使用 WebGPU\n//     const currentTarget =\n//       target || (this.engine.supportWebGPU ? Target.WGSL : Target.GLSL100);\n\n//     const computeData = {\n//       type,\n//       target: currentTarget,\n//       compiledBundle: {\n//         shaders: {\n//           [Target.WGSL]: '',\n//           [Target.GLSL450]: '',\n//           [Target.GLSL100]: '',\n//         },\n//         context: undefined,\n//       },\n//       dispatch,\n//       maxIteration,\n//       engine: this.engine,\n//       // onCompleted,\n//       // onIterationCompleted,\n//     };\n\n//     if (precompiledBundle) {\n//       // 预编译的结果应该包含所有目标平台的 Shader 代码\n//       computeData.compiledBundle = JSON.parse(precompiledBundle);\n//     }\n\n//     return this.compute.create(entity, computeData);\n//   }\n// }\n"],"file":"System.js"}