{"version":3,"sources":["../../../src/components/compute/ParticleComputeStrategy.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA","sourcesContent":["// import { inject, injectable } from 'inversify';\n// import { IRenderEngine } from '../..';\n// import { IDENTIFIER } from '../../identifier';\n// import { ComputeComponent } from './ComputeComponent';\n// import { IComputeStrategy } from './IComputeStrategy';\n\n// /**\n//  * 适合粒子特效场景，由于需要配合渲染，因此：\n//  * 1. 每一帧只需要 dispatch 一次\n//  * 2. 使用两个 buffer 进行 Ping-pong 操作\n//  * 3. 通常不需要设置最大迭代次数\n//  */\n// @injectable()\n// export class ParticleComputeStrategy implements IComputeStrategy {\n//   public component: ComputeComponent;\n\n//   @inject(IDENTIFIER.RenderEngine)\n//   private readonly engine: IRenderEngine;\n\n//   public init() {\n//     const component = this.component;\n\n//     // create particleBuffers\n//     // component.particleBuffers = [\n//     //   this.engine.createVertexBuffer(component.particleData, 128),\n//     //   this.engine.createVertexBuffer(component.particleData, 128),\n//     // ];\n\n//     // create GPUBuffers for uniform & storeage buffers\n//     // component.bindings.forEach((binding) => {\n//     //   if (binding.type === 'uniform-buffer' && binding.data) {\n//     //     binding.buffer = this.engine.createUniformBuffer(binding.data);\n//     //   } else if (binding.type === 'storage-buffer' && binding.data) {\n//     //     binding.buffer = this.engine.createVertexBuffer(binding.data, 128);\n//     //   }\n//     // });\n\n//     // create compute pipeline layout\n//     const computeBindGroupLayout = this.engine\n//       .getDevice()\n//       .createBindGroupLayout({\n//         entries: [\n//           {\n//             binding: 0,\n//             visibility: 4, // ShaderStage.Compute\n//             type: 'storage-buffer',\n//           },\n//           {\n//             binding: 1,\n//             visibility: 4,\n//             type: 'storage-buffer',\n//           },\n//           // ...component.bindings.map((binding) => ({\n//           //   binding: binding.binding,\n//           //   visibility: 4,\n//           //   type: binding.type,\n//           // })),\n//         ],\n//       });\n//     component.pipelineLayout = this.engine.getDevice().createPipelineLayout({\n//       bindGroupLayouts: [computeBindGroupLayout],\n//     });\n\n//     // for (let i = 0; i < 2; i++) {\n//     //   component.particleBindGroups[i] = this.engine\n//     //     .getDevice()\n//     //     .createBindGroup({\n//     //       layout: computeBindGroupLayout,\n//     //       entries: [\n//     //         {\n//     //           binding: 0,\n//     //           resource: {\n//     //             buffer: component.particleBuffers[i],\n//     //             offset: 0,\n//     //             size: component.particleData.byteLength,\n//     //           },\n//     //         },\n//     //         {\n//     //           binding: 1,\n//     //           resource: {\n//     //             buffer: component.particleBuffers[(i + 1) % 2],\n//     //             offset: 0,\n//     //             size: component.particleData.byteLength,\n//     //           },\n//     //         },\n//     //         ...component.bindings.map((binding) => ({\n//     //           binding: binding.binding,\n//     //           resource: {\n//     //             buffer: binding.buffer!,\n//     //             offset: 0,\n//     //             size: binding.data?.byteLength || 0,\n//     //           },\n//     //         })),\n//     //       ],\n//     //     });\n//     // }\n//   }\n\n//   public async run() {\n//     this.engine.dispatch(this.component.compiledBundle.context);\n//     this.component.iteration++;\n//   }\n\n//   public getBindingGroup() {\n//     return this.component.particleBindGroups[this.component.iteration % 2];\n//   }\n\n//   public getGPUBuffer() {\n//     return this.component.particleBuffers[this.component.iteration % 2];\n//   }\n\n//   public updateUniformGPUBuffer() {\n//     //\n//   }\n\n//   public destroy() {\n//     this.component.particleBuffers.forEach((buffer) => buffer.destroy());\n//   }\n// }\n"],"file":"ParticleComputeStrategy.js"}