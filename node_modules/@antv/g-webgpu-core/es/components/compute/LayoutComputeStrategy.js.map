{"version":3,"sources":["../../../src/components/compute/LayoutComputeStrategy.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA","sourcesContent":["// import { GLSLContext } from '@antv/g-webgpu-compiler';\n// import { inject, injectable } from 'inversify';\n// import concat from 'lodash/concat';\n// import { IRenderEngine } from '../..';\n// import { IDENTIFIER } from '../../identifier';\n// import { isSafari } from '../../utils/isSafari';\n// import { ComputeComponent } from './ComputeComponent';\n// import { IComputeStrategy } from './IComputeStrategy';\n\n// /**\n//  * 适合布局计算场景：\n//  * 1. 每一帧需要 dispatch 多次，以便尽快完成计算\n//  * 2. 只需要一个 GPUBuffer 存储初始节点和边数据\n//  * 3. 通常需要设置最大迭代次数，完成后返回最终 GPUBuffer 数据，供用户渲染结果\n//  */\n// @injectable()\n// export class LayoutComputeStrategy implements IComputeStrategy {\n//   public component: ComputeComponent;\n\n//   @inject(IDENTIFIER.RenderEngine)\n//   private readonly engine: IRenderEngine;\n\n//   private mergedUniformGPUBuffer: GPUBuffer;\n//   private uniformGPUBufferLayout: Array<{\n//     name: string;\n//     offset: number;\n//   }> = [];\n//   private vertexBuffers: GPUBuffer[] = [];\n\n//   public init(context: GLSLContext) {\n//     const component = this.component;\n\n//     if (this.engine.supportWebGPU) {\n//       const buffers = context.uniforms.filter(\n//         (uniform) => uniform.type === 'sampler2D' || 'image2D',\n//       );\n//       const uniforms = context.uniforms.filter(\n//         (uniform) => uniform.type !== 'sampler2D' && uniform.type !== 'image2D',\n//       );\n\n//       let bufferBindingIndex = uniforms.length ? 1 : 0;\n//       const bindGroupLayoutEntries = [];\n//       const bindGroupEntries = [];\n//       if (bufferBindingIndex) {\n//         let offset = 0;\n//         // FIXME: 所有 uniform 合并成一个 buffer，固定使用 Float32Array 存储，确实会造成一些内存的浪费\n//         const mergedUniformData = concat(\n//           uniforms.map((uniform) => {\n//             this.uniformGPUBufferLayout.push({\n//               name: uniform.name,\n//               offset,\n//             });\n//             // @ts-ignore\n//             offset += (uniform.data.length || 1) * 4;\n//             return uniform.data;\n//           }),\n//         );\n//         this.mergedUniformGPUBuffer = this.engine.createUniformBuffer(\n//           // @ts-ignore\n//           mergedUniformData,\n//         );\n\n//         bindGroupLayoutEntries.push({\n//           binding: 0,\n//           visibility: 4,\n//           type: 'uniform-buffer',\n//         });\n\n//         bindGroupEntries.push({\n//           binding: 0,\n//           resource: {\n//             buffer: this.mergedUniformGPUBuffer,\n//             offset: 0,\n//             size: mergedUniformData.length * 4, // 默认 Float32Array\n//           },\n//         });\n//       }\n\n//       // create GPUBuffers for storeage buffers\n//       buffers.forEach((buffer) => {\n//         if (buffer.data) {\n//           if (buffer.type === 'sampler2D') {\n//             // @ts-ignore\n//             const gpuBuffer = this.engine.createVertexBuffer(\n//               // @ts-ignore\n//               isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,\n//               128,\n//             );\n//             this.vertexBuffers.push(gpuBuffer);\n//             if (buffer.name === context.output.name) {\n//               context.output = {\n//                 name: buffer.name,\n//                 // @ts-ignore\n//                 length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,\n//                 typedArrayConstructor: Float32Array,\n//                 gpuBuffer,\n//               };\n//             }\n//             bindGroupEntries.push({\n//               binding: bufferBindingIndex,\n//               resource: {\n//                 buffer: gpuBuffer,\n//                 offset: 0,\n//                 size:\n//                   // @ts-ignore\n//                   (isFinite(Number(buffer.data)) ? 1 : buffer.data.length) *\n//                   (isFinite(Number(buffer.data))\n//                     ? 1\n//                     : // @ts-ignore\n//                       (buffer.data as Float32Array).BYTES_PER_ELEMENT || 4), // 默认 Float32Array\n//               },\n//             });\n//             bindGroupLayoutEntries.push({\n//               binding: bufferBindingIndex,\n//               visibility: 4,\n//               type: 'storage-buffer',\n//             });\n\n//             bufferBindingIndex++;\n//           } else if (buffer.type === 'image2D') {\n//             if (!buffer.size) {\n//               throw new Error(`The size of ${buffer.name} must be declared.`);\n//             }\n//             const gpuBuffer = this.engine.createTexture(\n//               buffer.size,\n//               // @ts-ignore\n//               buffer.data,\n//               4, // sampled-texture\n//             );\n//             const sampler = this.engine.createSampler({\n//               magFilter: 'linear',\n//               minFilter: 'linear',\n//             });\n\n//             bindGroupEntries.push({\n//               binding: bufferBindingIndex,\n//               resource: gpuBuffer.createView(),\n//             });\n//             bindGroupEntries.push({\n//               binding: bufferBindingIndex + 1,\n//               resource: sampler,\n//             });\n\n//             bindGroupLayoutEntries.push({\n//               binding: bufferBindingIndex,\n//               visibility: 4,\n//               type: 'sampled-texture',\n//             });\n//             bindGroupLayoutEntries.push({\n//               binding: bufferBindingIndex + 1,\n//               visibility: 4,\n//               type: 'sampler',\n//             });\n\n//             bufferBindingIndex += 2;\n//           }\n//         }\n//       });\n\n//       // create compute pipeline layout\n//       const computeBindGroupLayout = this.engine\n//         .getDevice()\n//         .createBindGroupLayout(\n//           isSafari\n//             ? // @ts-ignore\n//               { bindings: bindGroupLayoutEntries }\n//             : { entries: bindGroupLayoutEntries },\n//         );\n//       component.pipelineLayout = this.engine.getDevice().createPipelineLayout({\n//         bindGroupLayouts: [computeBindGroupLayout],\n//       });\n\n//       component.particleBindGroups[0] = this.engine.getDevice().createBindGroup(\n//         isSafari\n//           ? {\n//               layout: computeBindGroupLayout,\n//               // @ts-ignore\n//               bindings: bindGroupEntries,\n//             }\n//           : {\n//               layout: computeBindGroupLayout,\n//               entries: bindGroupEntries,\n//             },\n//       );\n//     }\n//   }\n\n//   public async run() {\n//     this.engine.dispatch(this.component.compiledBundle.context);\n//   }\n\n//   public getBindingGroup() {\n//     return this.component.particleBindGroups[0];\n//   }\n\n//   public getGPUBuffer() {\n//     return this.component.particleBuffers[0];\n//   }\n\n//   public updateUniformGPUBuffer(\n//     uniformName: string,\n//     data:\n//       | number\n//       | number[]\n//       | Float32Array\n//       | Uint8Array\n//       | Uint16Array\n//       | Uint32Array\n//       | Int8Array\n//       | Int16Array\n//       | Int32Array,\n//   ) {\n//     const layout = this.uniformGPUBufferLayout.find(\n//       (l) => l.name === uniformName,\n//     );\n\n//     if (layout) {\n//       this.engine.setSubData(\n//         this.mergedUniformGPUBuffer,\n//         layout.offset,\n//         Number.isFinite(data)\n//           ? new Float32Array([data as number])\n//           : new Float32Array(\n//               data as\n//                 | number[]\n//                 | Float32Array\n//                 | Uint8Array\n//                 | Uint16Array\n//                 | Uint32Array\n//                 | Int8Array\n//                 | Int16Array\n//                 | Int32Array,\n//             ),\n//       );\n//     }\n//   }\n\n//   public destroy() {\n//     if (this.component.particleBuffers[0]) {\n//       this.component.particleBuffers[0].destroy();\n//     }\n\n//     if (this.mergedUniformGPUBuffer) {\n//       this.mergedUniformGPUBuffer.destroy();\n//     }\n\n//     this.vertexBuffers.forEach((b) => b.destroy());\n//   }\n// }\n"],"file":"LayoutComputeStrategy.js"}