{"version":3,"sources":["../../../src/components/mesh/System.ts"],"names":["MeshSystem","IDENTIFIER","MeshComponentManager","CullableComponentManager","GeometryComponentManager","HierarchyComponentManager","TransformComponentManager","planes","views","view","scene","getScene","camera","getCamera","mesh","forEach","entity","component","hierarchyComponent","hierarchy","getComponentByEntity","cullableComponent","cullable","geometryComponent","geometry","meshTransform","transform","aabb","aabbDirty","worldTransform","center","halfExtents","transformedCenter","vec3","transformMat4","create","rotationScale","mat3","transformedHalfExtents","transformMat3","update","parentCullableComponent","parentID","visibilityPlaneMask","computeVisibilityWithPlaneMask","Mask","INDETERMINATE","getFrustum","visible","OUTSIDE","clear","parentPlaneMask","INSIDE","mask","k","len","length","flag","normal","distance","dot","getNegativeFarPoint","getPositiveFarPoint"],"mappings":"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","sourcesContent":["import { mat3, mat4, vec3 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport { ComponentManager } from '../../ComponentManager';\nimport { IDENTIFIER } from '../../identifier';\nimport { ISystem } from '../../ISystem';\nimport { AABB } from '../../shape/AABB';\nimport { Mask } from '../../shape/Frustum';\nimport { Plane } from '../../shape/Plane';\nimport { getRotationScale } from '../../utils/math';\nimport { GeometryComponent } from '../geometry/GeometryComponent';\nimport { MaterialComponent } from '../material/MaterialComponent';\nimport { IView } from '../renderer/IRendererService';\nimport { HierarchyComponent } from '../scenegraph/HierarchyComponent';\nimport { TransformComponent } from '../scenegraph/TransformComponent';\nimport { CullableComponent } from './CullableComponent';\nimport { IMeshParams } from './interface';\nimport { MeshComponent } from './MeshComponent';\n\n@injectable()\nexport class MeshSystem implements ISystem {\n  @inject(IDENTIFIER.MeshComponentManager)\n  private readonly mesh: ComponentManager<MeshComponent>;\n\n  @inject(IDENTIFIER.CullableComponentManager)\n  private readonly cullable: ComponentManager<CullableComponent>;\n\n  @inject(IDENTIFIER.GeometryComponentManager)\n  private readonly geometry: ComponentManager<GeometryComponent>;\n\n  @inject(IDENTIFIER.HierarchyComponentManager)\n  private readonly hierarchy: ComponentManager<HierarchyComponent>;\n\n  @inject(IDENTIFIER.TransformComponentManager)\n  private readonly transform: ComponentManager<TransformComponent>;\n\n  private planes: Plane[];\n\n  public setFrustumPlanes(planes: Plane[]) {\n    this.planes = planes;\n  }\n\n  public async execute(views: IView[]) {\n    for (const view of views) {\n      const scene = view.getScene();\n      const camera = view.getCamera();\n      // get VP matrix from camera\n      this.mesh.forEach((entity, component) => {\n        const hierarchyComponent = this.hierarchy.getComponentByEntity(entity);\n        const cullableComponent = this.cullable.getComponentByEntity(entity);\n        const geometryComponent = component.geometry;\n        const meshTransform = this.transform.getComponentByEntity(entity);\n\n        // update mesh.aabb\n        if (\n          geometryComponent &&\n          geometryComponent.aabb &&\n          meshTransform &&\n          component.aabbDirty\n        ) {\n          const { worldTransform } = meshTransform;\n\n          // apply transform to geometry.aabb\n          const { center, halfExtents } = geometryComponent.aabb;\n          const transformedCenter = vec3.transformMat4(\n            vec3.create(),\n            center,\n            worldTransform,\n          );\n\n          const rotationScale = getRotationScale(worldTransform, mat3.create());\n          const transformedHalfExtents = vec3.transformMat3(\n            vec3.create(),\n            halfExtents,\n            rotationScale,\n          );\n\n          component.aabb.update(transformedCenter, transformedHalfExtents);\n          component.aabbDirty = false;\n        }\n\n        // culling\n        if (cullableComponent && geometryComponent) {\n          const parentCullableComponent = this.cullable.getComponentByEntity(\n            hierarchyComponent?.parentID || -1,\n          );\n          cullableComponent.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(\n            component.aabb,\n            parentCullableComponent?.visibilityPlaneMask || Mask.INDETERMINATE,\n            this.planes || camera.getFrustum().planes,\n          );\n          cullableComponent.visible =\n            cullableComponent.visibilityPlaneMask !== Mask.OUTSIDE;\n        }\n      });\n    }\n  }\n\n  public tearDown() {\n    this.cullable.clear();\n    this.mesh.clear();\n  }\n\n  /**\n   *\n   * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」\n   * @see https://github.com/antvis/GWebGPUEngine/issues/3\n   *\n   * * 基础相交测试 the basic intersection test\n   * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/\n   * * TODO: 平面一致性测试 the plane-coherency test\n   * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy\n   *\n   * @param aabb aabb\n   * @param parentPlaneMask mask of parent\n   * @param planes planes of frustum\n   */\n  public computeVisibilityWithPlaneMask(\n    aabb: AABB,\n    parentPlaneMask: Mask,\n    planes: Plane[],\n  ) {\n    if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {\n      // 父节点完全位于视锥内或者外部，直接返回\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = Mask.INSIDE;\n\n    for (let k = 0, len = planes.length; k < len; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // 父节点处于当前面内部，可以跳过\n        continue;\n      }\n\n      // 使用 p-vertex 和 n-vertex 加速，避免进行平面和 aabb 全部顶点的相交检测\n      const { normal, distance } = planes[k];\n      if (\n        vec3.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance >\n        0\n      ) {\n        return Mask.OUTSIDE;\n      }\n      if (\n        vec3.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance >\n        0\n      ) {\n        // 和当前面相交，对应位置为1，继续检测下一个面\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n"],"file":"System.js"}