"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeometrySystem = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _initializerDefineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerDefineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _applyDecoratedDescriptor2 = _interopRequireDefault(require("@babel/runtime/helpers/applyDecoratedDescriptor"));

var _initializerWarningHelper2 = _interopRequireDefault(require("@babel/runtime/helpers/initializerWarningHelper"));

var _glMatrix = require("gl-matrix");

var _inversify = require("inversify");

var _2 = require("../..");

var _identifier = require("../../identifier");

var _aabb = require("../../utils/aabb");

var _gl = require("../renderer/gl");

var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2, _temp;

var primitiveUv1Padding = 4.0 / 64;
var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
var GeometrySystem = (_dec = (0, _inversify.injectable)(), _dec2 = (0, _inversify.inject)(_identifier.IDENTIFIER.GeometryComponentManager), _dec3 = (0, _inversify.inject)(_identifier.IDENTIFIER.RenderEngine), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {
  function GeometrySystem() {
    (0, _classCallCheck2.default)(this, GeometrySystem);
    (0, _initializerDefineProperty2.default)(this, "geometry", _descriptor, this);
    (0, _initializerDefineProperty2.default)(this, "engine", _descriptor2, this);
  }

  (0, _createClass2.default)(GeometrySystem, [{
    key: "execute",
    value: function () {
      var _execute = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _this = this;

        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.geometry.forEach(function (entity, component) {
                  // build buffers for each geometry
                  if (component.dirty) {
                    component.attributes.forEach(function (attribute) {
                      if (attribute.dirty && attribute.data) {
                        if (!attribute.buffer) {
                          attribute.buffer = _this.engine.createBuffer({
                            data: attribute.data,
                            type: _gl.gl.FLOAT
                          });
                        } else {
                          var _attribute$buffer;

                          (_attribute$buffer = attribute.buffer) === null || _attribute$buffer === void 0 ? void 0 : _attribute$buffer.subData({
                            data: attribute.data,
                            // TODO: support offset in subdata
                            offset: 0
                          });
                        }

                        attribute.dirty = false;
                      }
                    }); // create index buffer if needed

                    if (component.indices) {
                      if (!component.indicesBuffer) {
                        component.indicesBuffer = _this.engine.createElements({
                          data: component.indices,
                          count: component.indices.length,
                          type: _gl.gl.UNSIGNED_INT,
                          usage: _gl.gl.STATIC_DRAW
                        });
                      } else {
                        component.indicesBuffer.subData({
                          data: component.indices,
                          offset: 0
                        });
                      }
                    }

                    component.dirty = false;
                  }
                });

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function execute() {
        return _execute.apply(this, arguments);
      }

      return execute;
    }()
  }, {
    key: "tearDown",
    value: function tearDown() {
      this.geometry.forEach(function (_, geometry) {
        if (geometry.indicesBuffer) {
          geometry.indicesBuffer.destroy();
        }

        geometry.attributes.forEach(function (attribute) {
          if (attribute.buffer) {
            attribute.buffer.destroy();
          }
        });
      });
      this.geometry.clear();
    }
    /**
     * @see https://threejs.org/docs/#api/en/core/BufferGeometry
     */

  }, {
    key: "createBufferGeometry",
    value: function createBufferGeometry() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        vertexCount: 3
      },
          vertexCount = _ref.vertexCount;

      var entity = (0, _2.createEntity)();
      return this.geometry.create(entity, {
        vertexCount: vertexCount
      });
    }
    /**
     * @see https://threejs.org/docs/#api/en/core/InstancedBufferGeometry
     */

  }, {
    key: "createInstancedBufferGeometry",
    value: function createInstancedBufferGeometry(_ref2) {
      var maxInstancedCount = _ref2.maxInstancedCount,
          vertexCount = _ref2.vertexCount;
      var entity = (0, _2.createEntity)();
      return this.geometry.create(entity, {
        maxInstancedCount: maxInstancedCount,
        vertexCount: vertexCount
      });
    }
    /**
     * ported from PlayCanvas
     * @param params BoxGeometryParams
     * @return entity
     */

  }, {
    key: "createBox",
    value: function createBox() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var ws = params.widthSegments || 1;
      var hs = params.heightSegments || 1;
      var ds = params.depthSegments || 1;

      var _ref3 = params.halfExtents || _glMatrix.vec3.fromValues(0.5, 0.5, 0.5),
          _ref4 = (0, _slicedToArray2.default)(_ref3, 3),
          hex = _ref4[0],
          hey = _ref4[1],
          hez = _ref4[2];

      var corners = [_glMatrix.vec3.fromValues(-hex, -hey, hez), _glMatrix.vec3.fromValues(hex, -hey, hez), _glMatrix.vec3.fromValues(hex, hey, hez), _glMatrix.vec3.fromValues(-hex, hey, hez), _glMatrix.vec3.fromValues(hex, -hey, -hez), _glMatrix.vec3.fromValues(-hex, -hey, -hez), _glMatrix.vec3.fromValues(-hex, hey, -hez), _glMatrix.vec3.fromValues(hex, hey, -hez)];
      var faceAxes = [[0, 1, 3], // FRONT
      [4, 5, 7], // BACK
      [3, 2, 6], // TOP
      [1, 0, 4], // BOTTOM
      [1, 4, 2], // RIGHT
      [5, 0, 6] // LEFT
      ];
      var faceNormals = [[0, 0, 1], // FRONT
      [0, 0, -1], // BACK
      [0, 1, 0], // TOP
      [0, -1, 0], // BOTTOM
      [1, 0, 0], // RIGHT
      [-1, 0, 0] // LEFT
      ];
      var sides = {
        FRONT: 0,
        BACK: 1,
        TOP: 2,
        BOTTOM: 3,
        RIGHT: 4,
        LEFT: 5
      };
      var positions = [];
      var normals = [];
      var uvs = [];
      var uvs1 = [];
      var indices = [];
      var vcounter = 0;

      var generateFace = function generateFace(side, uSegments, vSegments) {
        var u;
        var v;
        var i;
        var j;

        for (i = 0; i <= uSegments; i++) {
          for (j = 0; j <= vSegments; j++) {
            var temp1 = _glMatrix.vec3.create();

            var temp2 = _glMatrix.vec3.create();

            var temp3 = _glMatrix.vec3.create();

            var r = _glMatrix.vec3.create();

            _glMatrix.vec3.lerp(temp1, corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);

            _glMatrix.vec3.lerp(temp2, corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);

            _glMatrix.vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);

            _glMatrix.vec3.add(r, temp1, temp3);

            u = i / uSegments;
            v = j / vSegments;
            positions.push(r[0], r[1], r[2]);
            normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
            uvs.push(u, v); // pack as 3x2
            // 1/3 will be empty, but it's either that or stretched pixels
            // TODO: generate non-rectangular lightMaps, so we could use space without stretching

            u /= 3;
            v /= 3;
            u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
            v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
            u += side % 3 / 3;
            v += Math.floor(side / 3) / 3;
            uvs1.push(u, v);

            if (i < uSegments && j < vSegments) {
              indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
              indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
            }

            vcounter++;
          }
        }
      };

      generateFace(sides.FRONT, ws, hs);
      generateFace(sides.BACK, ws, hs);
      generateFace(sides.TOP, ws, ds);
      generateFace(sides.BOTTOM, ws, ds);
      generateFace(sides.RIGHT, ds, hs);
      generateFace(sides.LEFT, ds, hs); // generate AABB

      var aabb = (0, _aabb.generateAABBFromVertices)(positions);
      var entity = (0, _2.createEntity)();
      return this.geometry.create(entity, {
        indices: Uint32Array.from(indices),
        aabb: aabb,
        attributes: [{
          dirty: true,
          name: 'position',
          data: Float32Array.from(positions),
          arrayStride: 4 * 3,
          stepMode: 'vertex',
          attributes: [{
            shaderLocation: 0,
            offset: 0,
            format: 'float3'
          }]
        } // {
        //   dirty: true,
        //   name: 'normal',
        //   data: Float32Array.from(normals),
        //   arrayStride: 4 * 3,
        //   stepMode: 'vertex',
        //   attributes: [
        //     {
        //       shaderLocation: 1,
        //       offset: 0,
        //       format: 'float3',
        //     },
        //   ],
        // },
        // {
        //   dirty: true,
        //   name: 'uv',
        //   data: Float32Array.from(uvs),
        //   arrayStride: 4 * 2,
        //   stepMode: 'vertex',
        //   attributes: [
        //     {
        //       shaderLocation: 2,
        //       offset: 0,
        //       format: 'float2',
        //     },
        //   ],
        // },
        ]
      }); // TODO: barycentric & tangent
    }
  }]);
  return GeometrySystem;
}(), _temp), (_descriptor = (0, _applyDecoratedDescriptor2.default)(_class2.prototype, "geometry", [_dec2], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
}), _descriptor2 = (0, _applyDecoratedDescriptor2.default)(_class2.prototype, "engine", [_dec3], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: null
})), _class2)) || _class);
exports.GeometrySystem = GeometrySystem;
//# sourceMappingURL=System.js.map